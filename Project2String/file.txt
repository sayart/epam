







Helper Java

Основные заметки по курсу Java Начало































Составил Коновалов А.А.(tohak199@gmail.com)


I. Переменные

Простые числовые типы:
Тип	Разрядность	MIN	MAX
byte	8 бит	-128	127
short	16 бит	-32768	32767
int	32 бит	-2147483648	2147483647
long	64 бит	-9223372036854775808	9223372036854775807
float	32 бит	-3.4E+38	3.4E+38
double	64 бит	-1.7E+308	1.7E+308

Системы счисления:
десятичная
Двоичная: ob
Шестнадцатеричная:  ox

Как сконвертировать строку?
String mString = "42"; // строка
int mInt = Integer.parseInt(mString);
Как сконвертировать число в строку?
Если сложить число и строку, то Java автоматически конвертирует число в строку. Пользуясь этим свойством, программисты часто прибавляют к числу пустую строку. Но лучше использовать метод valueOf():
int number = 1;
// плохой вариант
String numberString = "" + number;
// отличный вариант
String numberString = String.valueOf(number);
Символьные:
Char — один символ.
String – строка.
Логические:
Boolean  – да или нет.


II операторы:
Условные операторы:
Оператор	Пример использования	Возвращает значение "истинно", если...
>	a > b	а больше b
>=	a >= b	а больше или равно b
<	a < b	а меньше b
<=	a <= b	а меньше или равно b
==	a == b	а равно b
!=	a != b	а не равно b
&&	a && b	а и b истинны, b оценивается условно (если а ложно, b не вычисляется)
||	a || b	а или b истинно, b оценивается условно (если а истинно, b не вычисляется)
!	!a	а ложно
&	a & b	а и b истинны, b оценивается в любом случае
|	a | b	а или b истинно, b оценивается в любом случае
^	a ^ b	а и b различны

Математические операции Math.
Существуют также гиперболические функции: sinh(), cosh(), tanh().
Экспоненциальные функции: cbrt(), exp(), expm1(), log(), log10(), log1p(), pow(), scalb(), sqrt().
Из них хорошо знакомы возведение в степень - pow(2.0, 3.0) вернёт 8.0. И квадратный корень - sqrt(4.0).
Функции округления:
•	abs() - возвращает абсолютное значение аргумента
•	ceil() - возвращает наименьшее целое число, которое больше аргумента
•	floor() - возвращает наибольшее целое число, которое меньше или равно аргументу
•	max() - возвращает большее из двух чисел
•	min() - возвращает меньшее из двух чисел
•	nextAfter() - возвращает следующее значение после аргумента в заданном направлении
•	nextUp() - возвращает следующее значение в положительном направлении
•	rint() - возвращает ближайшее целое к аргументу
•	round() - возвращает аргумент, округлённый вверх до ближайшего числа
•	ulp() - возвращает дистанцию между значением и ближайшим большим значением
Другие методы
•	copySign() - возвращает аргумент с тем же знаком, что у второго аргумента
•	getExponent() - возвращает экспоненту
•	IEEEremainder() - возвращает остаток от деления
•	hypot() - возвращает длину гипотенузы
•	random() - возвращает случайное число между 0 и 1 (единица в диапазон не входит)
•	signum() - возвращает знак значения
•	toDegrees() - преобразует радианы в градусы
•	toRadians() - преобразует градусы в радианы

Логические операторы:
Оператор	Описание
&	Логическое AND (И)
&&	Сокращённое AND
|	Логическое OR (ИЛИ)
||	Сокращённое OR
^	Логическое XOR (исключающее OR (ИЛИ))
!	Логическое унарное NOT (НЕ)
&=	AND с присваиванием
|=	OR с присваиванием
^=	XOR с присваиванием
==	Равно
!=	Не равно
?:	Тернарный (троичный) условный оператор

Тернарный оператор:
логическое Условие ? выражение1 : выражение2
пример:
int absval, val;
val = 5;
absval = val < 0 ? -val : val;
// выводим число
mInfoTextView.setText("" + absval);
Побитовые операторы:
Существует несколько побитовых операторов, применимых к целочисленными типам long, int, short, char, byte.
~	Побитовый унарный оператор NOT
&	Побитовый AND
&=	Побитовый AND с присваиванием
|	Побитовый OR
|=	Побитовый OR с присваиванием
^	Побитовый исключающее OR
^=	Побитовый исключающее OR с присваиванием
>>	Сдвиг вправо
>>=	Сдвиг вправо с присваиванием
>>>	Сдвиг вправо с заполнением нулями
<<	Сдвиг влево
<<=	Сдвиг влево с присваиванием
>>>=	Сдвиг вправо с заполнением нулями с присваиванием
Побитовое OR (|)
Результирующий бит, полученный в результате выполнения оператора OR, |, равен 1, если соответствующий бит в любом из операндов равен 1.
 00101010  42
| 00001111  15
--------------
  00101111  47
Побитовое AND (&)
Значение бита, полученное в результате выполнения побитового оператора AND, &, равно 1, если соответствующие биты в операндах также равны 1. Во всех остальных случаях значение результирующего бита равно 0.
  00101010  42
& 00001111  15
--------------
  00001010  10
Побитовое XOR (^)
Результирующий бит, полученный в результате выполнения оператора XOR, ^, равен 1, если соответствующий бит только в одном из операндов равен 1. Во всех других случаях результирующий бит равен 0.
  00101010  42
^ 00001111  15
--------------
  00100101  37  
Побитовое NOT (~)
Унарный оператор NOT (Не), ~, называемый также побитовым дополнением, инвертирует все биты операнда. Например, число 42 в битовом представлении имеет вид:
00101010
В результате применения оператора NOT преобразуется в значение:
11010101
Оператор If:
if (условие) оператор;  // если условие истинно, то выполняется оператор

Существует расширенный вариант оператора if с использованием ключевого слова else:
if (условие) оператор;  // если условие истинно, то выполняется первый оператор
else оператор;          // если условие ложно, то выполняется оператор после else
Цепочка операторов if-else-if
Часто используется цепочка операторов if-else-if - конструкция, состоящая из вложенных операторов if:
if (condition)
    statement;
else if (condition)
    statement;
else if (condition)
    statement;
else
    statement;
Оператор switch
В отличие от операторов if-then и if-then-else, оператор switch применим к известному числу возможных ситуаций. Можно использовать простые типы byte, short, char, int. Также можно использовать Enum и String (начиная с JDK7), и специальные классы, которые являются обёрткой для примитивных типов: Character, Byte, Short, Integer.
Дублирование значений case не допускается. Тип каждого значения должен быть совместим с типом выражения.
Команду switch часто называют командой выбора. Выбор осуществляется в зависимости от целочисленного выражения. Форма команды выглядит так:
switch(ВыражениеДляСравнения) {
    case Совпадение1:
            команда;
                break;
        case Совпадение2:
            команда;
                break;
        case Совпадение3:
            команда;
                break;
        default:
            оператор;
            break;

III Циклы:
Цикл while
Оператор цикла while есть практически во всех языках программирования. Он повторяет оператор или блок операторов до тех пор, пока значение его управляющего выражения истинно.
Форма цикла while следующая:
while(условие) {
    // тело цикла}
Цикл do-while
Конструкция цикла:
do
    // команда (тело цикла)
while(условие-логическое выражение)
Отличие цикла do-while от цикла while состоит в том, что цикл do-while выполняется по крайней мере один раз, даже если условие изначально ложно. В цикле while такое не произойдёт, так как тело цикла не отработается. Цикл do-whileиспользуется реже, чем while.
Бывают ситуации, когда проверку прерывания цикла желательно выполнять в конце цикла, а не в его начале. И данный цикл позволяет это сделать. При каждом повторении цикла do-while программа сначала выполняет тело цикла, а затем вычисляет условное выражение. Если это выражение истинно, то цикл повторяется. В противном случае выполнение цикла прерывается. Как и в других циклах Java, условие должно иметь булево значение.
Перепишем пример из урока по циклу while на новый лад с использованием цикла do-while:

int counter = 10;
do {
    mInfoTextView.append("Осталось " + counter + " сек.\n");
        counter--;
} while (counter > 0);
Цикл for
Конструкция for управляет циклами. Команда выполняется до тех пор, пока управляющее логическое выражение не станет ложным.
for(инициализация; логическое выражение (условие); шаг (итерация))
    команда
for (int x = 0; x < 9; x = x + 1)
                mInfoTextView.append("\nЗначение x: " + x);

Оператор break
Оператор break завершает последовательность операторов в операторе switch, позволяет выйти из цикла и в качестве оператора безусловного перехода (goto).
for(int i = 0; i < 100; i++) {
    if(i == 5) break; // выходим из цикла, если i равно 5
        mInfoTextView.append("i: " + i + "\n");
}
mInfoTextView.append("Цикл завершён");
Оператор continue
ногда требуется, чтобы повторение цикла начиналось с более раннего оператора его тела. В циклах while и do-whileоператор continue вызывает передачу управления непосредственно управляющему условному выражению цикла. В цикле for управление передаётся вначале итерационной части цикла for, а потом условному выражению. При этом во всех циклах промежуточный код пропускается.
В следующем примере выводим два числа в каждой строке:
for (int i = 0; i < 10; i++) {
        mInfoTextView.append(i + " ");
        if (i % 2 == 0)
                continue;
        mInfoTextView.append("\n");
}
Оператор return
Оператор return используют для выполнения явного выхода из метода. Оператор можно использовать в любом месте метода для возврата управления тому объекту, который вызвал данный метод. Таким образом, return прекращает выполнение метода, в котором он находится.




IV Массивы:
Объявление массива
Переменную массива можно объявить с помощью квадратных скобок:
int[] cats;  // мы объявили переменную массива
Возможна и альтернативная запись:
int cats[]; // другой вариант
Инициализация массива
Не всегда нужно иметь значения по умолчанию. вы можете инициализировать массив собственными значениями, когда он объявляется, и определить количество элементов. Вслед за объявлением переменной массива добавьте знак равенства, за которым следует список значений элементов, помещенный в фигурные скобки. В этом случае ключевое слово new не используется:
int[] cats = {2, 5, 7, 8, 3, 0};  // массив из 6 элементов
Можно смешать два способа. Например, если требуется задать явно значения только для некоторых элементов массива, а остальные должные иметь значения по умолчанию.
int[] cats = new int[6]; // массив из шести элементов с начальным значением 0 для каждого элемента
cats[3] = 5; // четвертому элементу присвоено значение 5
cats[5] = 7; // шестому элементу присвоено значение 7
Перебор значений массива
Массивы часто используются для перебора всех значений. Стандартный способ через цикл for
int aNums[] = { 2, 4, 6 };
for (int i = 0; i < aNums.length; i++) {
    String strToPrint = "aNums[" + i + "]=" + aNums[i];
}


Также есть укороченный вариант записи
for (int num : aNums) {
    String strToPrint = num;
}
Нужно только помнить, что в этом случае мы не имеем доступа к индексу массива, что не всегда подходит для задач. Поэтому используется только для обычного перебора элементов.
Двумерный массив
Двумерный массив - это массив одномерных массивов. Если вам нужен двумерный массив, то используйте пару квадратных скобок:
String[][] arr = new String[4][3];
Для двумерных массивов часто используются два цикла for, чтобы заполнить элементы данными слева направо и сверху вниз. Напишем такой код:
int[][] twoD = new int[3][4]; // объявили двухмерный массив
int i, j, k = 0;
for (i = 0; i < 3; i++)
        for (j = 0; j < 4; j++) {
                twoD[i][j] = k;
                k++;
        }
for (i = 0; i < 3; i++) {
        for (j = 0; j < 4; j++)
                mInfoTextView.append(twoD[i][j] + " ");
        mInfoTextView.append("\n");
}
Класс Arrays
Класс java.util.Arrays предназначен для работы с массивами. Он содержит удобные методы для работы с целыми массивами:
•	copyOf() − предназначен для копирования массива
•	copyOfRange() − копирует часть массива
•	toString() − позволяет получить все элементы в виде одной строки
•	sort() — сортирует массив методом quick sort
•	binarySearch() − ищет элемент методом бинарного поиска
•	fill() − заполняет массив переданным значением (удобно использовать, если нам необходимо значение по умолчанию для массива)
•	equals() − проверяет на идентичность массивы
•	deepEquals() − проверяет на идентичность массивы массивов
•	asList() − возвращает массив как коллекцию
Сортировка массива
Сортировка (упорядочение по значениям) массива a производится методами Arrays.sort(a) и Arrays.sort(a, index1, index2). Первый метод упорядочивает в порядке возрастания весь массив, второй — часть элементов (от индекса index1 до индекса index2). Имеются и более сложные методы сортировки. Элементы массива должны быть сравниваемы (поддерживать операцию сравнения).
Простой пример
// задаём числа в случайном порядке
int[] numbers = new int[]{1, 23, 3, 8, 2, 4, 4};
// сортируем
Arrays.sort(numbers);
// проверяем
mInfoTextView.setText(Arrays.toString(numbers));
Сортировка массива для ArrayAdapter
Массивы часто используются в адаптерах для заполнения данными компоненты Spinner, ListView и т.п.
Предположим, у вас есть массив строк и его нужно отсортировать перед отдачей массива адаптеру ArrayAdapter. Это позволит вывести строки в упорядоченном виде, например, в ListView:

String[] catsNames = {
                "Васька",
                "Кузя",
                "Барсик",
                "Мурзик",
                "Леопольд",
                "Бегемот",
                "Рыжик",
                "Матроскин"
                };
// Сортируем перед передачей адаптеру           
Arrays.sort(catsNames);
ArrayAdapter<String> adapter;
 adapter = new ArrayAdapter<>(
                this,
                android.R.layout.simple_list_item_1,
                catsNames);
 setListAdapter(adapter);
У метода sort() есть перегруженные версии, где можно указать диапазон массива, в пределах которого следует произвести сортировку.
Копирование массивов
Метод Arrays.copyOf(оригинальный_массив, новая_длина) — возвращает массив-копию новой длины. Если новая длина меньше оригинальной, то массив усекается до этой длины, а если больше, то дополняется нулями.
// первый массив
int[] anyNumbers = {2, 8, 11};
// копия второго массива
int[] luckyNumbers = Arrays.copyOf(anyNumbers, anyNumbers.length);
luckyNumbers[2] = 25;
mInfoTextView.setText("anyNumbers: " + Arrays.toString(anyNumbers)
        + "\nluckyNumbers: " + Arrays.toString(luckyNumbers));
Теперь первый массив останется без изменений, а со вторым массивом делайте что хотите. Смотрим на результат.
anyNumbers: [2, 8, 11];
luckyNumbers: [2, 8, 25];
Можно создать увеличенную копию, когда копируются все значения из маленького массива, а оставшиеся места заполняются начальными значениями, например, нулями.
// три элемента
int[] small_array = {1, 2, 3};
// создадим массив с пятью элементами
int[] big_array = Arrays.copyOf(small_array, 5);
mInfoTextView.setText("big_array: " + Arrays.toString(big_array));
Получим результат:
big_array: [1, 2, 3, 0, 0]
Метод Arrays.copyOfRange(оригинальный_массив, начальный_индекс, конечный_индекс) — также возвращает массив-копию новой длины, при этом копируется часть оригинального массива от начального индекса до конечного –1.
// Массив из четырех элементов
String[] array_1 = {
        "Васька",
        "Мурзик",
        "Рыжик",
        "Барсик"};
// Сортировка массива
Arrays.sort(array_1);
// Копируем первые три элемента массива во второй массив
String[] array_2 = Arrays.copyOf(array_1, 3);
// Копируем нужные элементы из первого массива
// в диапазоне от второго элемента до последнего в третий массив
String[] array_3 = Arrays.copyOfRange(array_1,
        2, array_1.length);
Log.i(TAG, Arrays.toString(array_1));
Log.i(TAG, Arrays.toString(array_2));
Log.i(TAG, Arrays.toString(array_3));
Метод Arrays.toString()
Если использовать вызов метода toString() непосредственно у массива, то получите что-то непонятное и нечитаемое.
String[] catNames = {
        "Васька",
        "Мурзик",
        "Рыжик",
        "Барсик"};
Log.i(TAG, catNames.toString());
// Вернёт
[Ljava.lang.String;@4222bd88
Метод Arrays.toString(массив) возвращает строковое представление массива со строковым представлением элементов, заключенных в квадратные скобки. В примерах выше мы уже вызывали данный метод.
Метод deepToString() удобен для вывода многомерных массивов. Этот метод мы также уже использовали выше.
Метод Arrays.fill() - наполнение массива одинаковыми данными
Метод Arrays.fill() позволяет быстро заполнить массив одинаковыми значениями. У метода есть восемнадцать перегруженных версий для разных типов и объектов.
Метод fill() просто дублирует одно заданное значение в каждом элементе массива (в случае объектов копирует одну ссылку в каждый элемент):
int size = 4;
boolean[] test1 = new boolean[size];
int[] test2 = new int[size];
String[] test3 = new String[size];
Arrays.fill(test1, true); // присваивем всем true
Toast.makeText(getApplicationContext(), Arrays.toString(test1),
                Toast.LENGTH_LONG).show();
Arrays.fill(test2, 9); // присваиваем всем 9
Toast.makeText(getApplicationContext(), Arrays.toString(test2),
                Toast.LENGTH_LONG).show();
Arrays.fill(test3, "Мяу!"); // Ну вы поняли
Toast.makeText(getApplicationContext(), Arrays.toString(test3),
                Toast.LENGTH_LONG).show();
Запустив код, вы увидите, что на экране по очереди выводятся значения:
[true, true, true, true]
[9, 9, 9, 9]
[Мяу!, Мяу!, Мяу!, Мяу!]
Можно заполнить данными в нужном интервале за два прохода:
int size = 4;
String[] test3 = new String[size];
Arrays.fill(test3, "Мяу! ");
Arrays.fill(test3, 2, 3, "Гав!");
Toast.makeText(getApplicationContext(), Arrays.toString(test3),
                Toast.LENGTH_LONG).show();
Сначала массив заполнится мяуканьем кота 4 раза, а потом на третью позицию попадает слово Гав!:
[Мяу!, Мяу!, Гав!, Мяу!]
Как видите, метод заполняет весь массив, либо диапазон его элементов. Но получаемые одинаковые данные не слишком интересны для опытов, но пригодятся для быстрых экспериментов.
Метод equals() - сравнение массивов
Класс Arrays содержит метод equals() для проверки на равенство целых массивов. Чтобы два массива считались равными, они должны содержать одинаковое количество элементов, и каждый элемент должен быть эквивалентен соответствующему элементу другого массива.
Напишем код в своей учебной программе.
// Создаем два массива
int[] a1 = new int[10];
int[] a2 = new int[10];
// заполняем их девятками
Arrays.fill(a1, 9);
Arrays.fill(a2, 9);
mInfoTextView.setText("Сравним: " + Arrays.equals(a1, a2));
Мы создали два массива и заполнили их одинаковыми числами. При сравнении мы получим true. Добавим в код строчку кода, которая заменит один элемент во втором массиве:
//Изменим один элемент у второго массива
a2[3] = 11;
mInfoTextView.setText("Сравним: " + Arrays.equals(a1, a2));
Теперь при сравнении будет выдаваться false.




V Строки:
Класс String очень часто используется программистами, поэтому его следует изучить очень хорошо.
Следует помнить, что объекты класса String являются неизменяемыми (immutable). Поэтому, когда вам кажется, что вы меняете строку, то на самом деле вы создаёте новую строку.
В Java есть специальные классы StringBuffer и StringBuilder, который допускают изменения в строке.
Классы String, StringBuffer, StringBuilder определены в пакете java.lang и доступны автоматически без объявления импорта. Все три класса реализуют интерфейс CharSequence.
Создать строку очень просто. Например, можно так:
String aboutCat = "Кот - это звучит гордо, а если наступить на хвост, то громко";
Можно создать массив строк:
String[] cats = {"Васька", "Барсик", "Мурзик"};
Можно создать пустой объект класса String:
String str = new String();
Можно создать строку через массив символов:
char[] chars = { 'c', 'a', 't' };
String str = new String(chars);
Есть ещё конструктор, позволяющий задать диапазон символьного массива. Вам нужно указать начало диапазона и количество символов для использования:

char[] chars = {'c', 'a', 't', 'a', 'm', 'a', 'r', 'a', 'n' };
String str = new String(chars, 0, 3);
Можно создать объект класса String из объекта классов StringBuffer и StringBuilder при помощи следующих конструкторов:

String(StringBuffer объект_StrBuf)
String(StringBuilder объект_StrBuild)
Форматирование строк
Предположим у нас есть строковый ресурс:

<string name="aboutcat">У кота по имени Барсик четыре лапы, один хвост. Ему 5 лет</string>
Чтобы вывести эту строку программно в элементе TextView, можно использовать код:

TextView tvCatsInfo = (TextView)findViewById(R.id.textView1);
tvCatsInfo.setText(R.string.aboutcat);
Представьте себе, что у вас несколько котов. Можно, конечно, завести для каждого кота свою строку. Но ведь строки очень похожи, меняются только имена и возраст. Также можно менять число лап и хвостов (что вы курите?).
В таких случаях можно применить форматирование строк. Нужно определить слова, которые мы будем менять и заменить их на специальный набор символов, которые начинаются с символа процента, затем идет число, увеличивающееся на единицу, далее $s для строк или $d для чисел. Итак, изменим наш строковой ресурс так:

<string name="aboutcat">У кота по имени %1$s %2$s лапы, %3$s хвост. Ему %4$d лет</string>
Внесём изменения в код:

String strBarsik = "Барсик";
String strPaws = "четыре";
String strTail = "один";
int year = 5;  
String strCats = getResources().getString(R.string.aboutcat);  
String strFinal = String.format(strCats, strBarsik, strPaws, strTail, year);  
tvCatsInfo.setText(strFinal);
Если вас есть кот Васька и ему шесть лет, то добавляем две переменные и форматируем строку

String strVaska = "Васька";
year = 6;
String strFinal = String.format(strCats, strVaska, strPaws, strTail, year);  
tvCatsInfo.setText(strFinal);
Здесь показан простейший пример с форматированием. Помните о нём и применяйте в нужных местах.





Методы
public char charAt (int index)
Возвращает символ с указанным смещением в этой строке. Отсчёт идет от 0. Не надо использовать отрицательные и несуществующие значения, будьте серьёзнее. Для извлечения нескольких символов используйте getChars().

String testString = "Котёнок";
char myChar = testString.charAt(2);
tv.setText(Character.toString(myChar)); // выводит третий символ - т
public int codePointAt(int index)
Возвращает Unicode-символ в заданном индексе
String testString = "Котёнок";
int myChar = testString.codePointAt(3);
tv.setText(String.valueOf(myChar)); // возвращает 1105
public int codePointBefore(int index)
Возвращает Unicode-символ, который предшествует данному индексу
String testString = "Котёнок";
int myChar = testString.codePointBefore(4);
tv.setText(String.valueOf(myChar)); // возвращает 1105
public int codePointCount(int start, int end)
Вычисляет количество Unicode-символов между позициями start и end
String testString = "Котёнок";
int myChar = testString.codePointCount(0, 3);
tv.setText(String.valueOf(myChar)); // возвращает 3
public int compareTo(String string)
Сравнивает указанную строку, используя значения символов Unicode и вычисляет, какая из строк меньше, равна или больше следующей. Может использоваться при сортировке. Регистр учитывается. Если строки совпадают, то возвращается 0, если меньше нуля, то вызывающая строка меньше строки string, если больше нуля, то вызывающая строка больше строки string. Слова с большим регистром стоят выше слова с нижним регистром.
String testString = "Котёнок";
if (testString.compareTo("котёнок") == 0) {
    tvInfo.setText("Строки равны");
} else {
    tvInfo.setText("Строки не равны. Возвращено"
            + testString.compareTo("котёнок")); // возвращает -32
}
Отсортируем массив строк через пузырьковую сортировку.
String[] poem = { "Мы", "везём", "с", "собой", "кота" };

for (int j = 0; j < poem.length; j++) {
        for (int i = j + 1; i < poem.length; i++) {
                if (poem[i].compareTo(poem[j]) < 0) {
                        String temp = poem[j];
                        poem[j] = poem[i];
                        poem[i] = temp;
                }
        }
        System.out.println(poem[j]);
}
В результате мы получим:
Мы
везём
кота
с
собой
Как видите, от перемены мест слагаемых сумма сортировки коты не меняются.
public int compareToIgnoreCase (String string)
Сравнивает указанную строку, используя значения символов Unicode, без учета регистра.
String testString = "Котёнок";
if (testString.compareToIgnoreCase("котёнок") == 0) {
    tv.setText("Строки равны"); // слова одинаковы, если не учитывать регистр
} else {
    tv.setText("Строки не равны. Возвращено"
            + testString.compareTo("котёнок"));
}
public String concat (String string)
Объединяет строку с указанной строкой. Возвращается новая строка, которая содержит объединение двух строк. Обратите внимание, что само имя метода содержит кота!

String testString = "Сук";
String newString = testString.concat("кот");
tv.setText(newString);
Метод выполняет ту же функцию, что и оператор + и можно было написать Сук + кот. Но настоящий кошатник будет использовать "кошачий" метод.
public boolean contains (CharSequence cs)
Определяет, содержит ли строка последовательность символов в CharSequence

String testString = "котёнок";

if(testString.contains("кот")){
    infoTextView.setText("В слове котёнок содержится слово кот!");}
public boolean contentEquals(CharSequence cs)
Сравнивает CharSequence с этой строкой.
public boolean contentEquals(StringBuffer strbuf)
Сравнивает StringBuffer с этой строкой
public static String copyValueOf (char[] data, int start, int length)
Создаёт новую строку, содержащую указанные символы из массива Data начиная с позиции start (нумерация начинается с нуля) длинной length.
public static String copyValueOf(char[] data)
Создаёт новую строку, содержащую символы из указанного массива. Изменение массива после создания строки не изменяет созданную строку.
public boolean endsWith(String suffix)
Проверяет, заканчивается ли строка символами suffix.
String str1 = "Суккот";
if(str1.endsWith("кот"))
    infoTextView.setText("Слово заканчивается на котике");
else
    infoTextView.setText("Плохое слово. Нет смысла его использовать");
public boolean equals (Object string)
Сравнивает указанный объект и строку и возвращает true, если сравниваемые строки равны, т.е. содержит те же символы и в том же порядке с учётом регистра.
String str1 = "Кот";
String str2 = "Кошка";
if(str1.equals(str2))
    infoTextView.setText("Строки совпадают");
else
    infoTextView.setText("Строки не совпадают");    
Не путать метод с оператором ==, который сравнивает две ссылки на объекты и определяет, ссылаются ли они на один и тот же экземпляр.
public boolean equalsIgnoreCase(String string)
Сравнивает указанную строку с исходной строкой без учёта регистра и возвращает true, если они равны. Диапазон A-Z считается равным диапазону a-z.
String str1 = "Кот";
String str2 = "кот";

if(str1.equalsIgnoreCase(str2))
    infoTextView.setText("Строки совпадают");
else
    infoTextView.setText("Строки не совпадают");
public static String format(Locale locale, String format, Object... args)
Возвращает отформатированную строку, используя прилагаемый формат и аргументы, локализованных в данной области. Например дату или время
// выводим число типа float с двумя знаками после запятойString.format("%.2f", floatValue);
Склеиваем два слова, которые выводятся с новой строки. При этом второе слово выводится в верхнем регистре.
String str1 = "Кот";
String str2 = "васька";
String strResult = String.format("%s\n%S", str1, str2);
// выводим результат в TextView
infoTextView.setText(strResult);
Конвертируем число в восьмеричную систему.
String str1 = "8";
int inInt = Integer.parseInt(str1); // конвертируем строку в число
String strResult = String.format("(Восьмеричное значение): %o\n", inInt);
infoTextView.setText(strResult);
По аналогии выводим в шестнадцатеричной системе
String str1 = "255";
int inInt = Integer.parseInt(str1);
String strResult = String.format("(Шестнадцатеричное значение): %x\n", inInt);
// число 255 будет выведено как ff
infoTextView.setText(strResult);
Для верхнего регистра используйте %X, тогда вместо ff будет FF.
Для десятичной системы используйте %d.
Дату тоже можно выводить по разному.
Date now = new Date();
Locale locale = Locale.getDefault();
infoTextView.setText(
                String.format(locale, "%tD\n", now) + // (MM/DD/YY)
                String.format(locale, "%tF\n", now) + // (YYYY-MM-DD)
                String.format(locale, "%tr\n", now) + // Full 12-hour time
                String.format(locale, "%tz\n", now) + // Time zone GMT offset
                String.format(locale, "%tZ\n", now)); // Localized time zone bbreviation
public byte[] getBytes(String charsetName)
Возвращает отформатированную строку, используя прилагаемый формат.
public void getBytes(int start, int end, byte[] data, int index) и другие перегруженные версии
Метод сохраняет символы в массив байтов, альтернатива методу getChars(). Часто используется при экспорте строк из различных источников, где используются другие символы Unicode. Например, Java по умолчанию работает с 16-битовые символы Unicode, а в интернете часто строки используют 8-битовый код Unicode, ASCII и др.
public void getChars(int start, int end, char[] buffer, int index)
Метод для извлечения нескольких символов из строки. Вам надо указать индекс начала подстроки (start), индекс символа, следующего за концом извлекаемой подстроки (end). Массив, который принимает выделенные символы находится в параметре buffer. Индекс в массиве, начиная с которого будет записываться подстрока, передаётся в параметре index. Следите, чтобы массив был достаточного размера, чтобы в нём поместились все символы указанной подстроки.
String unusualCat = "Котёнок по имени Гав";
int start = 5;
int end = 12;
char[] buf = new char[end - start];
unusualCat.getChars(start, end, buf, 0);
infoTextView.setText(new String(buf));
public int hashCode()
Возвращает целое число — хэш-код для данного объекта.
public int indexOf(int c)
Возвращает номер первой встречной позиции с указанным индексом с.
String testString = "котёнок";
// символ ё встречается в четвёртой позиции (index = 3)
infoTextView.setText(String.valueOf(testString.indexOf("ё")));
public int indexOf (int c, int start)
Ищет индекс с, начиная с позиции start
String testString = "котёнок";
// вернёт -1, так как после 5 символа буквы ё нет
infoTextView.setText(String.valueOf(testString.indexOf("ё", 4)));
public int indexOf (String string)
Ищет цепочку символов subString
String testString = "У окошка";
infoTextView.setText(String.valueOf(testString.indexOf("кошка")));
public int indexOf (String subString, int start)
Ищет цепочку символов subString, начиная с позиции start
String testString = "У окошка";
infoTextView.setText(String.valueOf(testString.indexOf("кошка", 2)));
public String intern ()
«Xэширует» строку
public boolean isEmpty ()
Проверяет, является ли строка пустой
if(catname.isEmpty()) {
    // здесь ваш код
}
Данный метод появился в API 9 (Android 2.1). Для старых устройств используйте String.length() == 0
public int lastIndexOf (String string) и другие перегруженные версии
Возвращает номер последней встречной позиции с указанным индексом. Например, получить имя файла без расширения можно так:
filename.toString().substring(0, filename.getString().lastIndexOf("."));
В этом примере мы получаем позицию последней точки и получаем подстроку до неё.
public int length()
Возвращает длину строки

String testString = "котёнок";

infoTextView.setText(String.valueOf(testString.length())); // возвращает 7 (семь символов)
public boolean matches(String regularExpression)
Проверяет, соответствует ли строка регулярным выражениям.
public int offsetByCodePoints (int index, int codePointOffset)
Возвращает позицию, расположенную на расстоянии codePointOffset после начальной позиции, заданной параметром index


public boolean regionMatches (int thisStart, String string, int start, int length)
Метод сравнивает указанную часть строки с другой частью строки. Нужно задать индекс начала диапазон строки вызывающего объекта класса String. Строка для сравнивания передаётся в параметре string. Индекс символа, начиная с которого нужно выполнять сравнение передаётся в параметре start, а длина сравниваемой подстроки в параметреlength.
public boolean regionMatches (boolean ignoreCase, int thisStart, String string, int start, int length)
Перегруженная версия. Метод сравнивает указанную часть строки с другой частью строки, игнорируя регистр.
public String replace(CharSequence target, CharSequence replacement) и другие перегруженные версии
Меняет символ или последовательность символов target на replacement
String testString = "кит";
// меняем и на о
infoTextView.setText(testString.replace("и", "о")); // возвращается кот
public String replaceAll (String regularExpression, String replacement)
int i = Integer.parseInt("kitty123".replaceAll("[\\D]",""));
int j = Integer.parseInt("123kitty".replaceAll("[\\D]",""));
int k = Integer.parseInt("1k2it3ty".replaceAll("[\\D]",""));

// Вернет
i = 123;
j = 123;
k = 123;
public String replaceFirst (String regularExpression, String replacement)
Удаляет первые символы при помощи регулярного выражения.
Например, если нужно удалить нули в начале чисел 001, 007, 000024, то можно использовать такой вызов.
String s = "001234-cat";
String s = s.replaceFirst ("^0*", ""); // останется 1234-cat
public String[] split (String regularExpression) и другие перегруженные версии
Разбивает строку на массив из слов. Например, есть строка Васька Рыжик Мурзик Барсик и мы хотим получить массив имён котов:
String catnames = "Васька Рыжик Мурзик Барсик";  
String aCats[] = catnames.split(" ");  // по пробелу
Получим:
aCats[0] = Васька
aCats[1] = Рыжик
aCats[2] = Мурзик
aCats[3] = Барсик
public boolean startsWith(String prefix)
Проверяет, начинается ли строка символами prefix с начала строки
String str1 = "котлета";

if(str1.startsWith("кот"))
    infoTextView.setText("Слово содержит кота");
else
    infoTextView.setText("Плохое слово. Нет смысла его использовать");
public boolean startsWith(String prefix, int start)
Проверяет, начинается ли заданная строка символами prefix с указанной позиции.
String str1 = "Суккот";
if(str1.startsWith("кот", 3))
    infoTextView.setText("Слово содержит кота");
else
    infoTextView.setText("Плохое слово. Нет смысла его использовать");
public CharSequence subSequence (int start, int end)
Аналогичен методу substring(), но может использоваться для CharSequence.


public String substring(int start) и другие перегруженные версии.
Создаёт новую последовательность/строку с символами из данной строки начиная с позиции start до конца строки/заканчивая символом с позиции end. Новая строка содержит символы от start до end - 1, поэтому берём на один символ больше.
String testString = "скотина";
infoTextView.setText(testString.substring(1, 4)); // возвращается кот
public char[] toCharArray()
Копирует символы в этой строке в массив символов. Тот же результат можно получить через метод getChars(). Документация не рекомендует использовать данный метод, предлагая метод charAt().
String unusualCat = "Котёнок по имени Гав";

char[] yomoe = unusualCat.toCharArray();
infoTextView.setText(String.valueOf(yomoe[3]));
public String toLowerCase() и другие перегруженные версии
Преобразовывает строку в нижний регистр. Преобразованием управляет заданный по умолчанию региональный язык.
String cat = "Кот";
String lower = cat.toLowerCase();
infoTextView.setText(lower);
public String toUpperCase()
Преобразовывает строку в верхний регистр. Преобразованием управляет заданный по умолчанию региональный язык.
String cat = "Кот";
String upper = cat.toUpperCase();
infoTextView.setText(upper);
public String trim()
Удаляет пробелы в начале и в конце строки.
String str = "   Hello Kitty  ".trim();
infoTextView.setText(str);
public static String valueOf(long value) и другие перегруженные версии
Конвертирует содержимое (числа, объекты, символы, массивы символов) в строку.

int catAge = 7; // это число

infoTextView.setText(String.valueOf(catAge)); // преобразовано в строку
Генерируем случайную строку
Допустим, нам нужна случайная строка из заданных символов.

private static final String mCHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
private static final int STR_LENGTH = 9; // длина генерируемой строки
Random random = new Random();
    public void onClick(View view) {
    TextView infoTextView = (TextView) findViewById(R.id.textViewInfo);
    infoTextView.setText(createRandomString());
}
public String createRandomString() {
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < STR_LENGTH; i++) {
        int number = random.nextInt(mCHAR.length());
        char ch = mCHAR.charAt(number);
        builder.append(ch);
    }
    return builder.toString();
}
Сравнение строк: equals() или ==?
Рассмотрим пример.
String str1 = "Мурзик";
String str2 = new String(str1);
boolean isCat = str1 == str2;
infoTextView.setText(str1 + " == " + str2 + " -> " + isCat);
Хотя в двух переменных содержится одно и то же слово, мы имеем дело с двумя разными объектами и оператор ==вернёт false.
Однажды, когда деревья были большими, мне понадобилось сравнить две строки из разных источников. Хотя строки выглядели совершенно одинаково, сравнение при помощи оператора == возвращало false и путало мне все карты. И только потом я узнал, что нужно использовать метод equals(). Строка в Java - это отдельный объект, который может не совпадать с другим объектом, хотя на экране результат выводимой строки может выглядеть одинаково. Просто Java в случае с логическим оператором == (а также !=) сравнивает ссылки на объекты (при работе с примитивами такой проблемы нет):
String s1 = "hello";
String s2 = "hello";
String s3 = s1;
String s4 = "h" + "e" + "l" + "l" + "o";
String s5 = new String("hello");
String s6 = new String(new char[]{'h', 'e', 'l', 'l', 'o'});
infoTextView.setText(s1 + " == " + s2 + ": " + (s1 == s2));
// попробуйте и другие варианты
// infoTextView.setText(s1 + " equals " + s2 + ": " + (s1.equals(s2)));

VI StringBuffer и StringBuilder
Класс String представляет собой неизменяемые последовательности символов постоянной длины и частое использование объектов класса занимают много места в памяти. Класс StringBuffer представляет расширяемые и доступные для изменений последовательности символов, позволяя вставлять символы и подстроки в существующую строку и в любом месте. Данный класс гораздо экономичнее в плане потребления памяти и настоятельно рекомендуется к использованию.
Существует четыре конструктора класса:
1.	StringBuffer() - резервирует место под 16 символов без перераспределения памяти
2.	StringBuffer(int capacity) - явно устанавливает размер буфера
3.	StringBuffer(String string) - устанавливает начальное содержимое и резервирует 16 символов без повторого резервирования
4.	StringBuffer(CharSequence cs) - создаёт объект, содержащий последовательность символов и резервирует место ещё под 16 символов
Методы класса StringBuffer
length()
Метод позволяет получить текущую длину объекта.
StringBuffer sb = new StringBuffer("Котэ");
tvInfo.setText("Длина: " + sb.length());
capacity()
Метод позволяет получить текущий объём выделенной памяти.
StringBuffer sb = new StringBuffer("Котэ");
tvInfo.setText("Объём памяти: " + sb.capacity()); // вернёт 20
Обратите внимание, что хотя слово состоит из четырёх символов, в памяти выделено запасное пространство для дополнительных 16 символов. Для такой простейшей операции выигрыша нет, но в сложных примерах, когда приходится на лету соединять множество строк, производительность резко возрастает.
ensureCapacity()
Можно предварительно выделить место для определённого количества символов, если собираетесь добавлять большое количество маленьких строк.
setLength(int length)
Устанавливает длину строки. Значение должно быть неотрицательным.
charAt(int index) и setCharAt(int index, char ch)
Можно извлечь значение отдельного символа с помощью метода charAt() и установить новое значение символа с помощью метода setCharAt(), указав индекс символа и его значение.

StringBuffer sb = new StringBuffer("Кит");
sb.setCharAt(1, 'o');
tvInfo.setText(sb.toString());
getChars()
Позволяет скопировать подстроку из объекта класса StringBuffer в массив. Необходимо позаботиться, чтобы массив был достаточного размера для приёма нужного количества символов указанной подстроки.
append()
Метод соединяет представление любого другого типа данных. Есть несколько перегруженных версий.
StringBuffer append(String string)
StringBuffer append(int number)
StringBuffer append(Object object)
Строковое представление каждого параметра за кулисами получают через метод String.valueOf() и затем полученные строки склеиваются в итоговую строку.
String str1 = "У кота ";
String str2 = " лапы";
int paws = 4;
StringBuffer sb = new StringBuffer(20);
sb.append(str1).append(paws).append(str2);
tvInfo.setText(sb.toString());
insert()
Вставляет одну строку в другую. Также можно вставлять значения других типов, которые будут автоматически преобразованы в строки. Вам надо указать индекс позиции, куда будет вставляться строка.
StringBuffer sb = new StringBuffer("Я Котов");
sb.insert(2, "Люблю ");
tvInfo.setText(sb.toString());
reverse()
Позволяет изменить порядок символов на обратный.
StringBuffer sb = new StringBuffer("МОКНЕТ ОКСАНА С КОТЕНКОМ");
sb.reverse();
tvInfo.setText(sb.toString());
У меня получилось практически то же самое, может метод глючит?
delete() и deleteCharAt()
Метод delete() удаляет последовательность символов, вам надо задать индекс первого символа, который надо удалить, а также индекс символа, следующего за последним из удаляемых. Метод deleteCharAt() удаляет один символ из указанной позиции.
replace()
Позволяет заменить один набор символов на другой. Нужно указать начальный и конечный индекс и строку замены.
substring()
Позволяет получить часть содержимого. Есть две формы метода. В первом случае нужно указать индекс начала позиции, с которой нужно получить подстроку. Во втором варианте указывается начальный индекс и конечный индекс, если нужно получить текст из середины строки.
Есть и другие методы
StringBuilder
Класс StringBuilder идентичен классу StringBuffer и обладает большей производительностью. Однако он не синхронизирован, поэтому его не нужно использовать в тех случаях, когда к изменяемой строке обращаются несколько потоков.
Создадим новый объект.

StringBuilder builder = new StringBuilder();
Добавляем новый фрагмент в существующую строку:

builder.append(ch); // можно добавить один символ
builder.append(sometext); // а можно добавить готовую строку
String completedString = builder.toString(); // результирующая строка
Соединять строки можно цепочкой.

new StringBuilder().append(s1).append(s2).append(s3).toString();
Данный код работает чуть быстрее, чем вызов append() по отдельности. Но это будет заметно при очень больших объёмах.

VII библиотека
Date
Класс Date предназначен для работы с текущими датой и временем и позволяет отталкиваться от них для решения своих задач. При выходе новых версий Java часть методов класса была перемещена в классы Calendar и DateFormat.
При импорте выбирайте java.util.Date, а не java.sql.Date.
У класса есть два конструктора:
Date()
Date(long milliseconds)
Первый конструктор без параметров инициализирует объект текущей датой и временем. Во втором конструкторе вы можете указать количество миллисекунд, прошедших с полуночи 1 января 1970 года.
Методы:
•	boolean after(Date date) - если объект класса Date содержит более позднюю дату, чем указано в параметре, то возвращается true
•	boolean before(Date date) - если объект класса Date содержит более раннюю дату, чем указано в параметре, то возвращается true
•	int compareTo(Date date) - сравнивает даты. Возвращает 0, если совпадают, отрицательное значение - если вызывающая дата более ранняя, положительное значение - если вызывающая дата более поздняя, чем в параметре
•	boolean equals(Object object) - если даты совпадают, то возвращается true
•	long getTime() - возвращает количество миллисекунд, прошедших с полуночи 1 января 1970 года
•	void setTime(long milliseconds) - устанавливает время и дату в виде числа миллисекунд, прошедших с полночи 1 января 1970 года.
Если вы посмотрите документацию, то увидите, что существует множество методов для получения или установки отдельных компонентов времени и даты, например, getMinutes()/setMinutes() и др. Все они являются устаревшими и вместо них следует использовать класс Calendar.
Простой пример вывода даты на экран.
// Создадим объект Date
Date date = new Date();
textViewInfo.setText(date.toString());
С помощью метода getTime() можно отобразить количество миллисекунд, прошедших с 1 января 1970 года. Обновим пример

// Создадим объект Date
Date date = new Date();

long millis = date.getTime();

textViewInfo.setText(String.valueOf(millis));
Calendar
Абстрактный класс Calendar позволяет преобразовать время в миллисекундах в более удобном виде - год, месяц, день, часы, минуты, секунды. Существуют также подклассы, например, GregorianCalendar.
Переменная типа boolean под именем areFieldsSet указывает, были установлены компоненты времени. Переменнаяfields - это массив целочисленных значений, содержащий компоненты времени. Переменная isSet - массив типаboolean, указывающий, был ли установлен специфический компонент времени. Переменная time (тип long) содержит текущее время объекта. Переменная isTimeSet (тип boolean) указывает, что было установлено текущее время.
У класса много методов. Вкратце опишем часть из них:
•	abstract void add(int field, int value) - добавляет value к компоненту времени или даты, указанному в параметреfield (например, Calendar.HOUR). Чтобы отнять, используйте отрицательное значение.
•	boolean after(Object calendar) - возвращает значение true, если вызывающий объект класса Calendar содержит более позднюю дату, чем calendar.
•	boolean before(Object calendar) - возвращает значение true, если вызывающий объект класса Calendar содержит более раннюю дату, чем calendar.
•	final void clear() - обнуляет все компоненты времени в вызывающем объекте.
•	final void clear(int field) - обнуляет компонент, указанный в параметре field
•	int get(int field) - возвращает значение одного компонента, например, Calendar.MINUTE
•	synchronized static Locale[] getAvailableLocales() - возвращает массив объектов класса Locale, содержащий региональные данные
•	synchronized static Calendar getInstance() - возвращает объект класса Calendar для региональных данных и часового пояса по умолчанию. Есть и другие перегруженные версии.
•	final Date getTime() - возвращает объекта класса Date, содержащий время, эквивалентное вызывающему объекту
•	TimeZone getTimeZone() - возвращает часовой пояс
•	final boolean isSet(int field) - возвращает значение true, если указанный компонент времени указан.
•	void set(int field, int value) - устанавливает компоненты даты или времени. Есть перегруженные версии
•	final void setTime(Date date) - устанавливает различные компоненты даты и времени через объект класса Date
•	void setTimeZone(TimeZone timezone) - устанавливает часовой пояс через объект класса TimeZone
Также в календаре определены много различных констант: AUGUST и другие месяцы, SATURDAY и другие дни недели,HOUR и т.д.
GregorianCalendar
Класс GregorianCalendar является подклассом Calendar, который представляет обычный Григорианский календарь. Метод getInstance() класса Calendar обычно возвращает объект класса GregorianCalendar, инициированный текущей датой и временем согласно региональным настройкам.
У класса есть два поля AD и BC - до нашей эры и наша эра.
Кроме стандартных методов, которые есть в классе Calendar, у GregorianCalendar есть метод isLeapYear() для проверки високосного года.
boolean isLeapYear(int year)
Если год високосный, то возвращается true.
Отсчёт месяцев идёт от нуля, поэтому декабрь будет одиннадцатым месяцем. Чтобы не путаться с такими случаями, проще использовать понятные константы:
GregorianCalendar calendar = new GregorianCalendar(1975,
                Calendar.DECEMBER, 31);
А получать нужные отрезки времени можно через метод get(). Например, узнать, какой месяц содержится в созданной нами дате можно так:

int month = calendar.get(Calendar.MONTH);
System.out.println(month); // вернёт 11
Изменить состояние объекта можно через метод set(). Например, установим новую дату у нашего объекта.
GregorianCalendar calendar = new GregorianCalendar(1975,
                Calendar.DECEMBER, 31);
calendar.set(1976, Calendar.FEBRUARY, 23);
// Убедимся, что возвращает 1 - февраль
System.out.println(calendar.get(Calendar.MONTH));
Можно сдвинуть дату на определённый период с помощью метода add(). Отодвинем дату на два месяца.
GregorianCalendar calendar = new GregorianCalendar(1975,
                Calendar.DECEMBER, 31);
calendar.add(Calendar.MONTH, 2);
System.out.println(calendar.get(Calendar.MONTH));
Методы getTime() и setTime() работают с объектами Date и полезны для преобразования.

GregorianCalendar calendar = new GregorianCalendar(year, month, day);
Date hireDay = calendar.getTime();
TimeZone
Класс TimeZone позволяет работать с часовыми поясами, смещёнными относительно Гринвича, также известного универсальное глобальное время (UTC). Класс также учитывает летнее время.
SimpleTimeZone
Класс SimpleTimeZone - подкласс класса TimeZone и позволяет работать с часовыми поясами в Григорианском календаре.
Класс DateFormat
Класс DateFormat является абстрактным классом, с помощью которого можно форматировать и анализировать показания даты и времени. метод getDateInstance() возвращает экземпляр класса DateFormat, который может форматировать информацию о дате.
Чаще всего используется метод format(), позволяющий вывести дату в нужном формате.
Класс SimpleDateFormat
Класс SimpleDateFormat является подклассом класса DateFormat и позволяет определять собственные шаблоны форматирования для отображения даты и времени.
Символы форматирования строки
•	A - AM или PM
•	d - день месяца (1-31)
•	D - день в году (1-366)
•	H - часы в формате AM/PM (1-12)
•	K - часы в формате суток (1-24)
•	M - минуты (0-59)
•	S - секунды (0-59)
•	W - неделя в году (1-53)
•	y - год
•	z - часовой пояс
и так далее.
Количество повторений символа определяет способ представления даты. Например, можно указать hh:mm:ss, а можноh:m:s. В первом случае будет отображаться ноль перед цифрой.


VIII ФАЙЛ:
В отличие от большинства классов ввода/вывода, класс File работает не с потоками, а непосредственно с файлами. Данный класс позволяет получить информацию о файле: права доступа, время и дата создания, путь к каталогу. А также осуществлять навигацию по иерархиям подкаталогов.
Класс java.io.File может представлять имя определённого файла, а также имена группы файлов, находящихся в каталоге. Если класс представляет каталог, то его метод list() возвращает массив строк с именами всех файлов.
Для создания объектов класса File можно использовать один из следующих конструкторов.
•	File(File dir, String name) - указывается объекта класса File (каталог) и имя файла
•	File(String path) - указывается путь к файлу без указания имени файла
•	File(String dirPath, Sring name) - указывается путь к файлу и имя файла
•	File(URI uri) - указывается объекта URI, описывающий файл
Методы класса File
Класс File может использоваться для создания каталога или дерева каталогов. Также можно узнать свойства файлов (размер, дату последнего изменения, режим чтения/записи), определить к какому типу (файл или каталог) относится объект File, удалить файл. У класса очень много методов, перечислим некоторые.
•	getAbsolutePath() - абсолютный путь файла, начиная с корня системы. В Android корневым элементом является символ слеша (/)
•	canRead() - доступно для чтения
•	canWrite() - доступно для записи
•	exists() - файл существует или нет
•	getName() - возвращает имя файла
•	getParent() - возвращает имя родительского каталога
•	getPath() - путь
•	lastModified() - дата последнего изменения
•	isFile() - объект является файлом, а не каталогом
•	isDirectory - объект является каталогом
•	isAbsolute() - возвращает true, если файл имеет абсолютный путь
•	renameTo(File newPath) - переименовывает файл. В параметре указывается имя нового имени файла. Если переименование прошло неудачно, то возвращается false
•	delete() - удаляет файл. Также можно удалить пустой каталог
Каталог
Каталог - это объект класса File, который содержит список других файлов и каталогов. После создания объекта классаFile, являющего каталогом, его метод isDirectory() вернёт значение true. И тогда вы можете вызывать метод list().
Для создания каталога можно использовать метод mkdir(), который вернёт true в успешном случае. Если указанный путь уже существует или каталог нельзя создать из-за отсутствия полного пути к нему, то вернётся false.
Метод mkdirs() создаёт сам каталог, так и всех его родителей.
Список каталогов
Если вы хотите получить содержимое каталога, то можно вызвать метод list() без аргументов. Вам вернётся полный список (массив) имён файлов и каталогов, содержащихся в данном каталоге. Есть ещё похожий метод listFiles(), который возвращает массив файлов (объектов, а не их имён), о котором поговорим отдельно.
String dirPath = "/";
File file = new File(dirPath);
File[] files = file.listFiles();
Если вам нужен только список файлов с расширением .java, то можно использовать специальный фильтр-класс, который описывает критерии отбора объектов File с помощью интерфейса FilenameFilter.
String[] list(FilenameFilter filter)
Интерфейс FilenameFilter определяет единственный метод accept(), вызываемый по одному разу с каждым файлом в списке.

boolean accept(File dir, String filename)
Метод возвращает true для файлов каталога, указанного в dir, которые должны быть включены в список, и false - для файлов, которые следует исключить.
Метод listFiles()
Метод имеет несколько перегруженных версий. Он возвращает список файлов в виде массива объектов класса File. Одна из версий метода также использует интерфейс FilenameFilter. Другая версия использует интерфейс FileFilter и возвращает те файлы, путевые имена которых соответствует интерфейсу.

